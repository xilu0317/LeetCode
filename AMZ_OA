https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Questions-2019

    Most Common Word
    Prison Cells After N Days
    K Closest Points to Origin
    Reorder Log Files
    Partition Labels
    Min Cost to Add New Roads
    Min distance to remove the obstacle
    Roll Dice
    Min Cost to Connect Ropes (Merge Files)
    Optimal Aircraft Utilization
    Longest string without 3 consecutive characters
    Movies on Flight
    Sort Center
    Longest string made up of only vowels
    Substrings of size K with K distinct chars



1. reorder server tag 
https://leetcode.com/problems/reorder-log-files/

2. 两个list 分别是 前/后台程序 <id, mem size>，问在total mem limit下最大组合（必须是一前一后）


2. Shortest path, Maze (2d array) (Robert / remove obstacle)
/*
[[1, 0, 0],
  [1, 0, 0],
  [1, 9 ,0]]
outout: 3 [0, 0] -> [1, 0] -> [2, 0] -> [2, 1]
*/



/**********************************************************************************************************
 Building Remove Obstacle - Time: O(mn)
 **********************************************************************************************************/
public static int removeObstacle(int numRows, int numColumns, List<List<Integer>> lot) {
    if (lot == null || lot.size() == 0) return 0;
    // Get the map array for convinience
    // initial a visited 2d array for later use
    int[][] map = new int[numRows][numColumns];
    int[][] visited = new int[numRows][numColumns];
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < numColumns; j++) {
            map[i][j] = lot.get(i).get(j);
        }
    }
 
    // BFS
    int res = 0;
    int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{0, 0});
    while (!queue.isEmpty()) {
        int size = queue.size();
        // interate the map layer by layer
        for (int i = 0; i < size; i++) {
            int[] cor = queue.poll();
            int x = cor[0];
            int y = cor[1];
            visited[x][y] = 1;
            if (map[x][y] == 9) return res;
            for (int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                // Get 4 directions, if out of bound or obstacle or visited, then not add to queue.
                if (nx < 0 || nx > numRows - 1 || ny < 0 || ny > numColumns - 1 || map[nx][ny] == 0 || visited[nx][ny] == 1)
                    continue;
                queue.offer(new int[]{nx, ny});
            }
        }
        res++;
    }
    return -1;
}
===
/**
 * FLAAG OA Remove Obstacle
 * @param numRows
 * @param numColumns
 * @param lot
 * @return
 */
var removeObstacle = function (numRows, numColumns, lot) {
    let step = 0;
    let twoS;
    lot[0][0] = 2;
    while (1) {
        twoS = [];
        let oriLot = JSON.parse(JSON.stringify(lot)).join(",");
        step++;
        for (i = 0; i < lot[0].length; i++)
            for (j = 0; j < lot.length; j++)
                if (lot[j][i] == 2) twoS.push([j, i]);
        for (point of twoS) {
            if (point[0] - 1 > -1)
                if (lot[point[0] - 1][point[1]] == 9) return step;
            if (point[0] + 1 < lot[0].length)
                if (lot[point[0] + 1][point[1]] == 9) return step;
            if (point[1] - 1 > -1)
                if (lot[point[0]][point[1] - 1] == 9) return step;
            if (point[1] + 1 < lot.length)
                if (lot[point[0]][point[1] + 1] == 9) return step;
            if (point[0] - 1 > -1 && lot[point[0] - 1][point[1]] == 1) lot[point[0] - 1][point[1]] = 2;
            if (point[0] + 1 < lot[0].length && lot[point[0] + 1][point[1]] == 1) lot[point[0] + 1][point[1]] = 2;
            if (point[1] - 1 > -1 && lot[point[0]][point[1] - 1] == 1) lot[point[0]][point[1] - 1] = 2;
            if (point[1] + 1 < lot.length && lot[point[0]][point[1] + 1] == 1) lot[point[0]][point[1] + 1] = 2;
        }
        if (oriLot == JSON.parse(JSON.stringify(lot)).join(",")) return -1;
    }
};


===

var b = 1;
function outer(){
    var b = 2
    function inner(){
        b++;
        console.log(b)
        var b = 3
        console.log(b)
    }
    inner();
}
outer();


Output to the console will be  undefined“3”.

There are three closures in the example, each with it’s own var b declaration. When a variable is invoked closures will be checked in order from local to global until an instance is found. Sinc
is NaN
     console.log(b) // output "NaN"
    b = 3; // b is 3
    console.log(b); // output "3"
}


1.零件组装： Write an algorithm to output the minimum possible time to put the N parts together and build the final product.
注意的一点， 如果input只有一个零件，要返回0.
2. 前后台进程: 输入：List<List<Integer>>一堆前台进程，List<List<Integer>>一堆后台进程，int memoryCapacit
0],[3,1000]], [[1,9000],[2,1000],[3,1000]], 10000,  输出: [[1,1],[3,1]]

1 two sum
2 874. Walking Robot Simulation

第一题 一个数组里有两种version 第一种version是用字母组成的 第二种是用数字组成的 要把字母的那些按abcd这种顺序sort排列好 后面接上所有数字类别的version 数字类别的保留原始顺序
就用最基本的sort做

第二题 两个求组 每个求组里拿一个数组成pair 找pair使得两个数和最接近且小于一个target
就sort第二个array 然后